<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Ergodic control">
<meta name="author" content="Sylvain Calinon">
<title>ICRA 2024 Tutorial on Ergodic Control</title>

<link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css'>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.9.1/font/bootstrap-icons.css">
<!--<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Barlow+Condensed|Montserrat&display=swap'>-->
<!--<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Arvo|Lato&display=swap'>-->
<!--<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Sedgwick+Ave+Display|Andika&display=swap'>-->
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Nixie+One|Ledger|Roboto+Mono&display=swap'>

<script defer src='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js'></script>

<py-config type="toml">
    packages = ['numpy']
    [[fetch]]
        from = './viewer3d/'
        files = ['viewer3d.py']
</py-config>
<link href="https://pyscript.net/latest/pyscript.css" rel="stylesheet"/>

<link rel="stylesheet" href="css/style.css">

</head>

<body id="page-top">

<!--   
<nav class="navbar navbar-default" style="margin-top: 0">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="#"> <img id="logo" src="http://i.imgur.com/McZjymS.png"></a>
    </div>
  </div>
</nav>
--->    

<nav class="navbar navbar-expand-md navbar-light mybg-header p-0">
    <div class="container-fluid">
        <div class="navbar-header">
            <a class="navbar-brand" href="index.html"><img style="height: 80px;" src="images/ergodic-logo.svg"></a>
        </div>
        <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse" data-bs-target="#collapseNavbar">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="collapseNavbar">
            3D Sandbox
            <ul class="navbar-nav ms-auto">   
                <li class="nav-item">
                  <a class="nav-link js-scroll-trigger" target="_blank" href="index.html">Ergodic Control Tutorial at ICRA 2024</a>
                </li>
            </ul>
        </div>
    </div>
</nav>


<div class="container-fluid">
<div class="row">
<!--<div class="col-sm-1"></div>-->
<div class="col-sm-7">

<br>

<ul class="nav nav-tabs" id="myTab" role="tablist">
<li class="nav-item" role="presentation">
<button aria-controls="SMC-tab-pane" aria-selected="true" class="nav-link active" data-bs-target="#SMC-tab-pane" data-bs-toggle="tab" id="SMC-tab" role="tab" type="button">SMC</button>
</li>
<li class="nav-item" role="presentation"> <button aria-controls="HEDAC-tab-pane" aria-selected="false" class="nav-link" data-bs-target="#HEDAC-tab-pane" data-bs-toggle="tab" id="HEDAC-tab" role="tab" type="button">HEDAC</button>
</li>
</ul>
<div class="tab-content" id="myTabContent">
<div aria-labelledby="SMC-tab" class="tab-pane fade show active" id="SMC-tab-pane" role="tabpanel" tabindex="0">
<py-repl error="errors" output="output">
# Initial robot state
x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]

# Number of Gaussians to represent the spatial distribution
param.nbGaussian = 2

# Gaussian centers
param.Mu = np.zeros((param.nbVar,param.nbGaussian))
param.Mu[:,0] = np.array([.8, .5, .5])
param.Mu[:,1] =  np.array([.8, .4, .6])

# Gaussian covariances
# direction vectors
Sigma1_v = np.array([.1, .1, 1.])
Sigma2_v = np.array([.1, 1., .1])
# scale
Sigma1_scale = 5E-1
Sigma2_scale = 3E-1
# regularization
Sigma1_regularization = np.eye(param.nbVar)*1E-3
Sigma2_regularization = np.eye(param.nbVar)*1E-3
param.Sigma = np.zeros((param.nbVar,param.nbVar,param.nbGaussian))
# construct the cov. matrix using the outer product
param.Sigma[:,:,0] = np.outer(Sigma1_v,Sigma1_v) * Sigma1_scale + Sigma1_regularization
param.Sigma[:,:,1] = np.outer(Sigma2_v,Sigma2_v) * Sigma2_scale + Sigma2_regularization

# Sampling from GMM to define the target
gaussian_id = np.random.choice(np.arange(0,param.nbGaussian))
param.target = np.random.multivariate_normal(param.Mu[:,gaussian_id],param.Sigma[:,:,gaussian_id])
param.target = np.clip(param.target, 0.1, 0.99) # Target within [0.1,1]

update_ergodic_smc_control()
</py-repl><br/>
</div>
<div aria-labelledby="HEDAC-tab" class="tab-pane fade" id="HEDAC-tab-pane" role="tabpanel" tabindex="0">
<py-repl error="errors" output="output">
# Initial robot state
x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]

# Number of Gaussians to represent the spatial distribution
param.nbGaussian = 2

# Gaussian centers
param.Mu = np.zeros((param.nbVar,param.nbGaussian))
param.Mu[:,0] = np.array([.8, .5, .5])
param.Mu[:,1] =  np.array([.8, .4, .6])

# Gaussian covariances
# direction vectors
Sigma1_v = np.array([.1, .1, 1.])
Sigma2_v = np.array([.1, 1., .1])
# scale
Sigma1_scale = 5E-1
Sigma2_scale = 3E-1
# regularization
Sigma1_regularization = np.eye(param.nbVar)*1E-3
Sigma2_regularization = np.eye(param.nbVar)*1E-3
param.Sigma = np.zeros((param.nbVar,param.nbVar,param.nbGaussian))
# construct the cov. matrix using the outer product
param.Sigma[:,:,0] = np.outer(Sigma1_v,Sigma1_v) * Sigma1_scale + Sigma1_regularization
param.Sigma[:,:,1] = np.outer(Sigma2_v,Sigma2_v) * Sigma2_scale + Sigma2_regularization

# Sampling from GMM to define the target
gaussian_id = np.random.choice(np.arange(0,param.nbGaussian))
param.target = np.random.multivariate_normal(param.Mu[:,gaussian_id],param.Sigma[:,:,gaussian_id])
param.target = np.clip(param.target, 0.1, 0.99) # Target within [0.1,1]

update_ergodic_hedac_control()
</py-repl>
</div>
</div>
<p id="repl-out" style="font-size: 70%; color: #777777;">(click on the green button to run the code)</p>
<p id="repl-err" style="font-size: 70%; color: #880000;"></p>
</div> <!--sm-7-->
<div class="col-sm-5">
<div class="sticky-sm-top" style="padding: 2rem 1rem 1rem 1rem;">
<div id="viewer3d" style="width: 100%; height: 600px;"></div>
<form>
<div class="row">
<div class="col-md"><center><span id="cost"></span></center></div>
</div>
</form>
</div>
</div> <!--sm-5-->
</div> <!--row-->

<!-- Import all the necessary JavaScript dependency modules
Sadly, can't be imported from an external file for the moment, this is not supported by Chrome
-->
<script async="" src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.141.0/build/three.module.js",
            "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.141.0/examples/jsm/",
            "mujoco": "./viewer3d/jsm/mujoco_wasm.js",
            "katex": "https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.mjs",
            "mathjs": "https://cdn.jsdelivr.net/npm/mathjs@12.0.0/+esm"
        }
    }
</script>

<!-- Import the viewer3d.js library -->
<script type="module">
    import { downloadScene, downloadPandaRobot, initPyScript } from './viewer3d/viewer3d.js';

    // Download the assets
    await downloadPandaRobot();
    await downloadScene('./viewer3d/scenes/panda.xml');

    // Now PyScript can be initialised
    initPyScript();
</script>

<py-script>
from viewer3d import Viewer3D, configs, Shapes
from js import document
from js import three
import numpy as np


## Parameters
# ===============================
param = lambda: None # Lazy way to define an empty class in python
param.nbFct = 10 # Number of basis functions along x and y
param.nbVar = 3 # Dimension of the space
param.nbGaussian = 2  # Number of Gaussians to represent the spatial distribution
param.target = np.array([.7, .5, .5])
param.target_radius = .03

param.mode = 'smc'

param.smc = lambda: None # All the smc-related parameters will go there
param.smc.x0 = np.array([.2, .3]) # Initial point
param.smc.dt = 1e-2 # Time step length

param.hedac = lambda: None # All the hedac-related parameters will go there
param.hedac.x0 = np.array([.7, .5, .0]) # Initial point
param.hedac.diffusion = 1  # increases global behavior
param.hedac.source_strength = 1  # increases local behavior
param.hedac.max_dx = 0.5 # maximum velocity of the agent
param.hedac.max_ddx = 0.1 # maximum acceleration of the agent
param.hedac.dx = 1
param.hedac.nbRes = 25 # resolution of discretization
param.hedac.min_kernel_val = 1e-8  # upper bound on the minimum value of the kernel
param.hedac.agent_radius = 1  # changes the effect of the agent on the coverage


## Variables
# ===============================

smc = lambda: None # All the smc-related variables will go there
hedac = lambda: None # All the hedac-related variables will go there

cost_el = document.getElementById('cost')


# SMC-related functions
# ===============================

def hadamard_matrix(n: int) -> np.ndarray:
    if n == 1:
        return np.array([[1]])

    # Recursively construct a Hadamard matrix of size n/2
    half_size = n // 2
    h_half = hadamard_matrix(half_size)

    h = np.empty((n, n), dtype=int)
    h[:half_size,:half_size] = h_half
    h[half_size:,:half_size] = h_half
    h[:half_size:,half_size:] = h_half
    h[half_size:,half_size:] = -h_half
    return h


def fourier(alpha):
    ## Compute Fourier series coefficients w_hat of desired spatial distribution
    w_hat = np.zeros(param.nbFct**param.nbVar)
    for j in range(param.nbGaussian):
        for n in range(smc.op.shape[1]):
            MuTmp = np.diag(smc.op[:,n]) @ param.Mu[:,j]
            SigmaTmp = np.diag(smc.op[:,n]) @ param.Sigma[:,:,j] @ np.diag(smc.op[:,n]).T
            cos_term = np.cos(smc.kk.T @ MuTmp)
            exp_term = np.exp(np.diag(-.5 * smc.kk.T @ SigmaTmp @ smc.kk))
            w_hat = w_hat + alpha[j] * cos_term * exp_term
    return w_hat / (param.L**param.nbVar) / (smc.op.shape[1])


def ergodic_control_smc_command(x, t, wt, param):
    # Depends on the current position only here, outputs: dphi, phix, phiy
    ang = x[:,np.newaxis] * smc.rg * param.omega
    phi1 = np.cos(ang) #Eq.(18)
    dphi1 = -np.sin(ang) * np.tile(smc.rg,(param.nbVar,1)) * param.omega
    phix = phi1[0,smc.xx-1].flatten()
    phiy = phi1[1,smc.yy-1].flatten()
    phiz = phi1[2,smc.zz-1].flatten()
    dphix = dphi1[0,smc.xx-1].flatten()
    dphiy = dphi1[1,smc.yy-1].flatten()
    dphiz = dphi1[2,smc.zz-1].flatten()
    dphi = np.vstack([[dphix * phiy * phiz], [phix * dphiy * phiz], [phix * phiy * dphiz]])

    # Depends on wt, wt starts with zeros, then updates
    wt = wt + (phix * phiy * phiz).T / (param.L**param.nbVar)

    # Depends on dphi, wt, smc.w_hat, t
    u = -dphi @ (smc.Lambda * (wt/(t+1) - smc.w_hat)) # Eq.(24)
    u = u * param.smc.u_max / (np.linalg.norm(u)+param.smc.u_norm_reg) # Velocity command

    return u, wt


def update_ergodic_smc_control():
    global smc, t, found_flag, param, trajectory, gaussians, target

    robot.jointPositions = x
    param.smc.x0 = robot.fkin(x)[:3]

    smc.op = hadamard_matrix(2**(param.nbVar-1))
    smc.op = np.array(smc.op[:3,:])
    smc.wt = np.zeros(param.nbFct**param.nbVar)

    smc.rg = np.arange(0, param.nbFct, dtype=float)
    smc.kk = np.ndarray((param.nbVar, param.nbFct**param.nbVar))

    for n in range(param.nbVar):
        smc.kk[n,:] = np.tile(np.repeat(smc.rg, param.nbFct**n), param.nbFct**(param.nbVar-n-1))

    # Weighting vector (Eq.(16))
    sp = (param.nbVar + 1) / 2 # Sobolev norm parameter
    smc.Lambda = (np.sum(smc.kk**2, axis=0) + 1).T**(-sp)

    smc.kk *= param.omega

    smc.w_hat = np.zeros(param.nbFct**param.nbVar)
    smc.yy, smc.zz, smc.xx = np.meshgrid(np.arange(1,param.nbFct+1), np.arange(1,param.nbFct+1), np.arange(1,param.nbFct+1))

    alpha = np.ones(param.nbGaussian) / param.nbGaussian # mixing coeffs. Priors

    smc.w_hat = fourier(alpha)

    smc.wt = np.zeros(param.nbFct**param.nbVar)
    param.smc.x0 = np.clip(param.smc.x0, 0.1, 0.99)
    smc.x = param.smc.x0.copy()

    t = 0
    found_flag = 0

    trajectory = np.ndarray((0, 3))

    viewer3D.removeTarget('target')
    viewer3D.removePath('trajectory')

    for gaussian in gaussians:
        viewer3D.removeGaussian(gaussian.name)

    gaussians = []
    for n in range(param.nbGaussian):
        gaussian = viewer3D.addGaussian(
            f'gaussian{n}',
            param.Mu[:,n],
            param.Sigma[:,:,n],
            '#0000aa',
            onGaussianModified
        )
        gaussians.append(gaussian)

    # Add the target
    target = viewer3D.addTarget(
        'target',
        param.target,
        orientation=[0.0, 0.0, 0.0, 1.0],
        color='#ff0000',
        shape=Shapes.Sphere,
        listener=onTargetMoved,
        parameters={
            'radius': param.target_radius,
        }
    )

    param.mode = 'smc'

    viewer3D.setRenderingCallback(ikUpdate)
    viewer3D.physicsSimulatorPaused = False

    cost_el.textContent = ''


# HEDAC-related functions
# ===============================

class SecondOrderAgent:
    """
    A point mass agent with second order dynamics.
    """
    def __init__(
        self,
        x,
        max_dx=1,
        max_ddx=0.2,
    ):
        self.x = np.array(x)  # position
        # determine which dimension we are in from given position
        self.nbVarX = len(x)
        self.dx = np.zeros(self.nbVarX)  # velocity

        self.t = 0  # time
        self.dt = 1  # time step

        self.max_dx = max_dx
        self.max_ddx = max_ddx

    def update(self, gradient):
        """
        set the acceleration of the agent to clamped gradient
        compute the position at t+1 based on clamped acceleration
        and velocity
        """
        ddx = gradient # we use gradient of the potential field as acceleration
        # clamp acceleration if needed
        if np.linalg.norm(ddx) > self.max_ddx:
            ddx = self.max_ddx * ddx / np.linalg.norm(ddx)

        s = str(self.x)

        self.x = self.x + self.dt * self.dx + 0.5 * self.dt * self.dt * ddx
        self.t += 1

        self.dx += self.dt * ddx  # compute the velocity
        # clamp velocity if needed
        if np.linalg.norm(self.dx) > self.max_dx:
            self.dx = self.max_dx * self.dx / np.linalg.norm(self.dx)


def clamp_kernel_1d(x, low_lim, high_lim, kernel_size):
    """
    A function to calculate the start and end indices
    of the kernel around the agent that is inside the grid
    i.e. clamp the kernel by the grid boundaries
    """
    start_kernel = low_lim
    start_grid = x - (kernel_size // 2)
    num_kernel = kernel_size
    # bound the agent to be inside the grid
    if x <= -(kernel_size // 2):
        x = -(kernel_size // 2) + 1
    elif x >= high_lim + (kernel_size // 2):
        x = high_lim + (kernel_size // 2) - 1

    # if agent kernel around the agent is outside the grid,
    # clamp the kernel by the grid boundaries
    if start_grid < low_lim:
        start_kernel = kernel_size // 2 - x - 1
        num_kernel = kernel_size - start_kernel - 1
        start_grid = low_lim
    elif start_grid + kernel_size >= high_lim:
        num_kernel -= x - (high_lim - num_kernel // 2 - 1)
    if num_kernel > low_lim:
        grid_indices = slice(start_grid, start_grid + num_kernel)

    return grid_indices, start_kernel, num_kernel


def agent_block(min_val, agent_radius):
    """
    A matrix representing the shape of an agent (e.g, RBF with Gaussian kernel). 
    min_val is the upper bound on the minimum value of the agent block.
    """
    eps = 1.0 / agent_radius  # shape parameter of the RBF
    l2_sqrd = (
        -np.log(min_val) / eps
    )  # squared maximum distance from the center of the agent block
    l2_sqrd_single = (
        l2_sqrd / param.nbVar
    )  # maximum squared distance on a single axis since sum of all axes equal to l2_sqrd
    l2_single = np.sqrt(l2_sqrd_single)  # maximum distance on a single axis
    # round to the nearest larger integer
    if l2_single.is_integer(): 
        l2_upper = int(l2_single)
    else:
        l2_upper = int(l2_single) + 1
    # agent block is symmetric about the center
    num_rows = l2_upper * 2 + 1
    num_cols = num_rows
    num_depths = num_rows
    block = np.zeros((num_depths, num_rows, num_cols))
    center = np.array([num_depths // 2, num_rows // 2, num_cols // 2])
    for k in range(num_depths):
        for i in range(num_rows):
            for j in range(num_cols):
                block[k, i, j] = rbf(np.array([k, i, j]), center, eps)
    return block


def offset(mat, i, j, k):
    """
    offset a 2D matrix by i, j
    """
    depths, rows, cols = mat.shape
    depths = depths - 2
    rows = rows - 2
    cols = cols - 2
    return mat[1 + i : 1 + i + depths, 1 + j : 1 + j + rows, 1 + k : 1 + k + cols]


def border_interpolate(x, length, border_type):
    """
    Helper function to interpolate border values based on the border type
    (gives the functionality of cv2.borderInterpolate function)
    """
    if border_type == "reflect101":
        if x < 0:
            return -x
        elif x >= length:
            return 2 * length - x - 2
    return x


def trilinear_interpolation(grid, pos):
    """
    Linear interpolating function on a 3-D grid
    """
    x, y, z = pos.astype(int)
    # find the nearest integers by minding the borders
    x0 = border_interpolate(x, grid.shape[1], "reflect101")
    x1 = border_interpolate(x + 1, grid.shape[1], "reflect101")
    y0 = border_interpolate(y, grid.shape[0], "reflect101")
    y1 = border_interpolate(y + 1, grid.shape[0], "reflect101")
    z0 = border_interpolate(z, grid.shape[0], "reflect101")
    z1 = border_interpolate(z + 1, grid.shape[0], "reflect101")
    # Distance from lower integers
    xd = pos[0] - x0
    yd = pos[1] - y0
    zd = pos[2] - z0
    # Interpolate on x-axis
    c00 = grid[z0, y0, x0] * (1 - xd) + grid[z0, y0, x1] * xd
    c01 = grid[z1, y0, x0] * (1 - xd) + grid[z1, y0, x1] * xd
    c10 = grid[z0, y1, x0] * (1 - xd) + grid[z0, y1, x1] * xd
    c11 = grid[z1, y1, x0] * (1 - xd) + grid[z1, y1, x1] * xd
    # Interpolate on y-axis
    c0 = c00 * (1 - yd) + c10 * yd
    c1 = c01 * (1 - yd) + c11 * yd
    # Interpolate on z-axis
    c = c0 * (1 - zd) + c1 * zd
    return c


def discretize_gmm(param):
    alpha = np.ones(param.nbGaussian) / param.nbGaussian # mixing coeffs. Priors
    w_hat = fourier(alpha)

    # Fourier basis functions (for a discretized map)
    xm1d = np.linspace(param.xlim[0], param.xlim[1], param.hedac.nbRes)  # Spatial range
    xm_yy, xm_zz, xm_xx = np.meshgrid(xm1d, xm1d, xm1d)

    # Range
    KX = np.ndarray((param.nbVar, param.nbFct**param.nbVar))

    for n in range(param.nbVar):
        KX[n,:] = np.tile(np.repeat(smc.rg, param.nbFct**n), param.nbFct**(param.nbVar-n-1))

    # Mind the flatten() !!!
    ang1 = (
        KX[0, :][:, np.newaxis]
        @ xm_xx.flatten()[:, np.newaxis].T
        * param.omega
    )
    ang2 = (
        KX[1, :][:, np.newaxis]
        @ xm_yy.flatten()[:, np.newaxis].T
        * param.omega
    )
    ang3 = (
        KX[2, :][:, np.newaxis]
        @ xm_zz.flatten()[:, np.newaxis].T
        * param.omega
    )
    phim = np.cos(ang1) * np.cos(ang2) * np.cos(ang3) * 2 ** (param.nbVar)
    # Some weird +1, -1 due to 0 index !!!
    yy, zz, xx = np.meshgrid(np.arange(1, param.nbFct + 1), np.arange(1, param.nbFct + 1), np.arange(1, param.nbFct + 1))
    hk = np.concatenate(([1], 2 * np.ones(param.nbFct)))
    HK = hk[xx.flatten() - 1] * hk[yy.flatten() - 1] * hk[zz.flatten() - 1]
    phim = phim * np.tile(HK, (param.hedac.nbRes**param.nbVar, 1)).T

    # Desired spatial distribution
    g = w_hat.T @ phim
    return g


def rbf(mean, x, eps):
    """
    Radial basis function w/ Gaussian Kernel
    """
    d = x - mean  # radial distance
    l2_norm_squared = np.dot(d, d)
    # eps is the shape parameter that can be interpreted as the inverse of the radius
    return np.exp(-eps * l2_norm_squared)


def normalize_mat(mat):
    return mat / (np.sum(mat) + 1e-10)


def calculate_gradient(agent, gradient_x, gradient_y, gradient_z):
    """
    Calculate movement direction of the agent by considering the gradient
    of the temperature field near the agent
    """
    # find agent pos on the grid as integer indices
    adjusted_position = agent.x / param.hedac.dx
    # note x axis corresponds to col and y axis corresponds to row
    col, row, depth = adjusted_position.astype(int)

    gradient = np.zeros(3)
    # if agent is inside the grid, interpolate the gradient for agent position
    if row > 0 and row < param.hedac.height - 1 and col > 0 and col < param.hedac.width - 1 and depth > 0 and depth < param.hedac.depth - 1:
        gradient[0] = trilinear_interpolation(gradient_x, adjusted_position)
        gradient[1] = trilinear_interpolation(gradient_y, adjusted_position)
        gradient[2] = trilinear_interpolation(gradient_z, adjusted_position)

    # if kernel around the agent is outside the grid,
    # use the gradient to direct the agent inside the grid
    boundary_gradient = 0.1 #2  # 0.1
    pad = param.hedac.kernel_size - 1
    if row <= pad:
        gradient[1] = boundary_gradient
    elif row >= param.hedac.height - 1 - pad:
        gradient[1] = -boundary_gradient

    if col <= pad:
        gradient[0] = boundary_gradient
    elif col >= param.hedac.width - pad:
        gradient[0] = -boundary_gradient

    if depth <= pad:
        gradient[2] = boundary_gradient
    elif depth >= param.hedac.depth - pad:
        gradient[2] = -boundary_gradient

    return gradient #* param.hedac.dx


def ergodic_control_hedac_command(agents, param):
    # find agent pos on the grid as integer indices
    p = hedac.agent.x
    adjusted_position = p / param.hedac.dx
    col, row, depth = adjusted_position.astype(int)

    # each agent has a kernel around it,
    # clamp the kernel by the grid boundaries
    row_indices, row_start_kernel, num_kernel_rows = clamp_kernel_1d(
        row, 0, param.hedac.height, param.hedac.kernel_size
    )
    col_indices, col_start_kernel, num_kernel_cols = clamp_kernel_1d(
        col, 0, param.hedac.width, param.hedac.kernel_size
    )
    depth_indices, depth_start_kernel, num_kernel_depths = clamp_kernel_1d(
        depth, 0, param.hedac.depth, param.hedac.kernel_size
    )

    # add the kernel to the coverage density
    # effect of the agent on the coverage density
    hedac.coverage_density[depth_indices, row_indices, col_indices] += hedac.coverage_block[
        depth_start_kernel : depth_start_kernel + num_kernel_depths,
        row_start_kernel : row_start_kernel + num_kernel_rows,
        col_start_kernel : col_start_kernel + num_kernel_cols,
    ]

    coverage = normalize_mat(hedac.coverage_density)

    # this is the part we introduce exploration problem to the Heat Equation
    diff = hedac.goal_density - coverage
    source = np.maximum(diff, 0) ** 3
    source = normalize_mat(source) * param.hedac.area

    current_heat = np.zeros((param.hedac.depth, param.hedac.height, param.hedac.width))

    # 2-D heat equation (Partial Differential Equation)
    # In 2-D we perform this second-order central for x and y.
    # Note that, delta_x = delta_y = h since we have a uniform grid.
    # Accordingly we have -4.0 of the center element.

    # At boundary we have Neumann boundary conditions which assumes
    # that the derivative is zero at the boundary. This is equivalent
    # to having a zero flux boundary condition or perfect insulation.
    current_heat[1:-1, 1:-1, 1:-1] = param.hedac.dt * (
        (
            + param.hedac.alpha[2] * offset(hedac.heat, 1, 0, 0)
            + param.hedac.alpha[2] * offset(hedac.heat, -1, 0, 0)
            + param.hedac.alpha[1] * offset(hedac.heat, 0, 1, 0)
            + param.hedac.alpha[1] * offset(hedac.heat, 0, -1, 0)
            + param.hedac.alpha[0] * offset(hedac.heat, 0, 0, 1)
            + param.hedac.alpha[0] * offset(hedac.heat, 0, 0, -1)
            - 6.0 * offset(hedac.heat, 0, 0, 0)
        )
        / (param.hedac.dx * param.hedac.dx * param.hedac.dx)
        + param.hedac.source_strength * offset(source, 0, 0, 0)
    ) + offset(hedac.heat, 0, 0, 0)

    hedac.heat = current_heat.astype(np.float32)

    # Calculate the first derivatives mind the order x and y
    gradient_z, gradient_y, gradient_x = np.gradient(hedac.heat, 1, 1, 1)

    grad = calculate_gradient(
        hedac.agent,
        gradient_x,
        gradient_y,
        gradient_z,
    )
    hedac.agent.update(grad)


def update_ergodic_hedac_control():
    global hedac, found_flag, param, controls, paths, trajectory, gaussians, target

    robot.jointPositions = x
    param.hedac.x0 = robot.fkin(x)[:3]
    param.hedac.x0 = np.clip(param.hedac.x0, 0.1, 0.99)

    # Initialize agents
    hedac.agent = SecondOrderAgent(x=param.hedac.x0 * param.hedac.nbRes, max_dx=param.hedac.max_dx, max_ddx=param.hedac.max_ddx)

    # Initialize heat equation related fields
    param.hedac.alpha = np.array([1, 1, 1]) * param.hedac.diffusion

    g = discretize_gmm(param)
    G = np.reshape(g, [param.hedac.nbRes, param.hedac.nbRes, param.hedac.nbRes])
    G = np.abs(G)    # there is no negative heat

    param.hedac.depth, param.hedac.height, param.hedac.width = G.shape

    param.hedac.area = param.hedac.dx * param.hedac.width * param.hedac.dx * param.hedac.height * param.hedac.dx * param.hedac.depth

    hedac.goal_density = normalize_mat(G)

    hedac.coverage_density = np.zeros((param.hedac.depth, param.hedac.height, param.hedac.width))
    hedac.heat = np.array(hedac.goal_density)

    max_diffusion = np.max(param.hedac.alpha)
    param.hedac.dt = min(
        1.0, (param.hedac.dx * param.hedac.dx * param.hedac.dx) / (8.0 * max_diffusion)
    )  # for the stability of implicit integration of Heat Equation
    hedac.coverage_block = agent_block(param.hedac.min_kernel_val, param.hedac.agent_radius)
    param.hedac.kernel_size = hedac.coverage_block.shape[0]

    # Other initializations
    t = 0
    found_flag = 0

    trajectory = np.ndarray((0, 3))

    viewer3D.removeTarget('target')
    viewer3D.removePath('trajectory')

    for gaussian in gaussians:
        viewer3D.removeGaussian(gaussian.name)

    gaussians = []
    for n in range(param.nbGaussian):
        gaussian = viewer3D.addGaussian(
            f'gaussian{n}',
            param.Mu[:,n],
            param.Sigma[:,:,n],
            '#0000aa',
            onGaussianModified
        )
        gaussians.append(gaussian)

    # Add the target
    target = viewer3D.addTarget(
        'target',
        param.target,
        orientation=[0.0, 0.0, 0.0, 1.0],
        color='#ff0000',
        shape=Shapes.Sphere,
        listener=onTargetMoved,
        parameters={
            'radius': param.target_radius,
        }
    )

    param.mode = 'hedac'

    viewer3D.setRenderingCallback(ikUpdate)
    viewer3D.physicsSimulatorPaused = False

    cost_el.textContent = ''


## Gaussians and target handling (using the mouse)
# ================================================

def onGaussianModified(gaussian, inProgress):
    if inProgress:
        return

    for i, gaussian in enumerate(gaussians):
        param.Mu[:,i] = gaussian.position
        param.Sigma[:,:,i] = gaussian.sigma

    if param.mode == 'smc':
        update_ergodic_smc_control()
    else:
        update_ergodic_hedac_control()


def onTargetMoved(target, inProgress):
    if inProgress:
        return

    param.target = target.position

    if param.mode == 'smc':
        update_ergodic_smc_control()
    else:
        update_ergodic_hedac_control()


#########################################################################################

# Gaussian centers
param.Mu = np.zeros((param.nbVar,param.nbGaussian))
param.Mu[:,0] = np.array([.8, .5, .5])
param.Mu[:,1] =  np.array([.8, .4, .6])

# Gaussian covariances
# direction vectors
Sigma1_v = np.array([.1, .1, 1.])
Sigma2_v = np.array([.1, 1., .1])
# scale
Sigma1_scale = 5E-1
Sigma2_scale = 3E-1
# regularization
Sigma1_regularization = np.eye(param.nbVar)*1E-3
Sigma2_regularization = np.eye(param.nbVar)*1E-3
param.Sigma = np.zeros((param.nbVar,param.nbVar,param.nbGaussian))
# construct the cov. matrix using the outer product
param.Sigma[:,:,0] = np.outer(Sigma1_v,Sigma1_v) * Sigma1_scale + Sigma1_regularization
param.Sigma[:,:,1] = np.outer(Sigma2_v,Sigma2_v) * Sigma2_scale + Sigma2_regularization

# Sampling from GMM to define the target
gaussian_id = np.random.choice(np.arange(0,param.nbGaussian))
param.target = np.random.multivariate_normal(param.Mu[:,gaussian_id],param.Sigma[:,:,gaussian_id])
param.target = np.clip(param.target, 0.1, 0.99) # Target within [0.1,1]


# Domain limit for each dimension (considered to be 1 for each dimension in this implementation)
param.xlim = [0.0, 1.0]
param.L = (param.xlim[1] - param.xlim[0]) * 2 # Size of [-xlim(2),xlim(2)]
param.omega = 2 * np.pi / param.L

param.smc.u_max = 1E1 # Maximum speed allowed
param.smc.u_norm_reg = 1E-1 # not sure what is this not to divide by zero?


# Create the Viewer3D object
viewer3D = Viewer3D(document.getElementById('viewer3d'))

# Load the scene and retrieve the robot
viewer3D.loadScene('/scenes/panda.xml')
robot = viewer3D.createRobot('panda', configs.Panda.new())

# Disable all robot controls (since the robot is controlled by our code)
# viewer3D.controlsEnabled = False
viewer3D.jointsManipulationEnabled = False
viewer3D.endEffectorManipulationEnabled = False
viewer3D.robotToolsEnabled = False


# Debug
# viewer3D.addPoint(
#     'O',
#     [0, 0, 0],
#     radius=param.target_radius,
#     color='#000000',
#     shading=True,
# )
#
# viewer3D.addPoint(
#     'X',
#     [1, 0, 0],
#     radius=param.target_radius,
#     color='#ff0000',
#     shading=True,
# )
#
# viewer3D.addPoint(
#     'Y',
#     [0, 1, 0],
#     radius=param.target_radius,
#     color='#00ff00',
#     shading=True,
# )
#
# viewer3D.addPoint(
#     'Z',
#     [0, 0, 1],
#     radius=param.target_radius,
#     color='#0000ff',
#     shading=True,
# )


# The function that will be called once per frame
t = 0

def ikUpdate(delta, time):
    global t, trajectory

    ee = robot.fkin(robot.jointPositions)
    if (np.linalg.norm(ee[:3] - target.position) < param.target_radius) or (trajectory.shape[0] == 500):
        viewer3D.setRenderingCallback(None)
        viewer3D.physicsSimulatorPaused = True

        if trajectory.shape[0] == 500:
            cost_el.textContent = 'Target not found after %d' % t + ' steps'
        else:
            cost_el.textContent = 'Target found in %d' % t + ' steps'
        return

    if (trajectory.shape[0] < 3) or (np.linalg.norm(trajectory[-2,:] - ee[:3]) >= 0.05):
        trajectory = np.append(trajectory, [ee[:3]], axis=0)
    else:
        trajectory[-1,:] = ee[:3]

    t += 1

    if param.mode == 'smc':
        smc.u, smc.wt = ergodic_control_smc_command(smc.x, t, smc.wt, param)
        smc.x += smc.u * param.smc.dt # Update of position
        robot.ik(smc.x, limit=20)
    else:
        ergodic_control_hedac_command(hedac.agent, param)
        robot.ik(hedac.agent.x / param.hedac.nbRes, limit=20)

    if trajectory.shape[0] > 1:
        viewer3D.removePath('trajectory')
        viewer3D.addPath(
            'trajectory',
            trajectory,
            0.005,
            '#ffff00',
            False,      # No shading
            True        # Transparent
        )


# Initial robot state
x = [0.5, -0.3, 0.0, -1.8, 0.0, 1.5, 1.0]

trajectory = None
gaussians = []
target = None

update_ergodic_smc_control()

</py-script>

</div> <!--container-->

<br><br><br><br><br><br><br><br><br><br><br>

<div class="navbar-light mybg-footer">
<br>
<center>Ergodic Control Tutorial at ICRA 2024</center>
<br>
</div>

</body>
</html>
